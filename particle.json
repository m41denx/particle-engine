{
  "name": "particle_name",
  "author": "Particle Author",
  "note": "Short note for some info",
  "block": "md5, autogenerated",
  "meta": {
    "name": "xHydra",
    "id": "000S",
    "icon": "000S.png"
  },
  "recipe": {
      "base": "fruitspace/gd_android@2.1",
      "apply": [
        "rainix/gd_patcher",
        "another/package@1.0"
      ],
      "engines": [
        "core/python@3.9",
        "core/bash"
      ],
      "run": [
        "python $src/main.py",
        "mv $src/pack.exe $dest/"
      ]
    }
}

/*
Партиклы просто есть и они работают похоже на докер - есть манифесты, которые содержат рецепты,
и есть 7zip архивы слоя, чтобы было здорово.

block - это md5 архива блока
meta это как переменные окружения, в принципе они и так в env: meta_name, meta_id, meta_icon
recipe это сам рецепт чтобы реально приготовить
  base это база, на основе которой будет собираться все остальное, она распаковывается в dist, база должна быть пассивным партиклом
  apply это партиклы которые нужно выполнить по порядку по отношению к базе.
    если партикл содержит run команды, то он помечается как активный и распаковывается в src/maintainer/particle_name@version
      в таком случае партикл выполняет команды из run чтобы перенести файлы в базу или патчить или что-то еще
    если партикл не содержит run команд, то он помечается как пассивный и его содержимое распаковывается напрямую в базу,
      где файлы перезаписываются при создании, патчатся при изменении и удаляются из списка в файле .deletions,
      который содержит список файлов для удаления
  engines это движки, нужные для запуска активных партиклов, они распаковываются в engines, переменные из .env загружаются
    в сессию и тот же питон работает без установки в портативном режиме, pip ставит пакеты локально
  run это команды которые запускает активный партикл с помощью движков, чтобы получить конечный результат

Конечный результат партикла это одно из двух: пассивный или активный
фактически активный партикл наследует пассивный потому что это скрипты, которые в первую очередь нужно просто хранить,
и только после этого запускать

Вот пример работы типичной цепочки партиклов:

user/program_pro (static)
 |__ base: org/program (static)
 |  |__ base: core/blank (static)
 |  |__ apply: org/win7_compat@0.5 (active)
 |     |__ base: core/blank (static)
 |     |__ run: ...
 |__ apply: user/program_hack (active)
    |__ base: core/blank (static)
    |__ run: ...


Как сделать свой партикл:
1) particle init
      создаст пустой манифест с базой core/blank и основные папки dist, engines, src и out
2) particle prepare
      готовит партикл из базы и apply (активных партиклов), а также составляет список md5 хэшей результата базы в integrity.json
3) здесь делаете свою мешанину в dist и допиливаете команды в run
4) particle build
      собирает партикл в out из dist, добавляя новые файлы как есть, изменения в патчфайлы filename.ext.patch
      (например config.xml изменился, пакуем config.xml.patch), удаления в .deletions.json. Все это пакуется в 7z
      и считается md5, который ставится в поле block манифеста
5) particle auth логин пароль
      позволяет войти в particle store
6) particle publish name
      публикует партикл в Particle Store
*/